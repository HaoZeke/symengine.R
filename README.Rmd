---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# symengine

[![Travis-CI Build Status](https://travis-ci.org/symengine/symengine.R.svg?branch=master)](https://travis-ci.org/symengine/symengine.R)
[![AppVeyor Build status](https://ci.appveyor.com/api/projects/status/rr0tdh8ykvs04qg2?svg=true)](https://ci.appveyor.com/project/symengine/symengine-r)

`symengine` is a R interface to the [SymEngine C++ library](https://github.com/symengine/symengine)
for symbolic computation.

## Installation

On Unix system, you may need install some system dependencies and compile the
symengine library manually. You can follow the instruction at 
https://github.com/symengine/symengine.

Alternatively, we have provided a convenient script to compile the symengine
library and install it to a non-root directory [`~/.local/rdeplibs-symengine`].
To use the script, first make sure you have installed `cmake`, `gmp` library,
`mpfr` library and `mpc` library on your system. For example, on openSUSE, Debian
or Mac OS, you will need:

```
zypper install cmake gmp-devel mpfr-devel mpc-devel    ## openSUSE
apt    install cmake libgmp-dev libmpfr-dev libmpc-dev ## Debian
brew   install cmake gmp mpfr libmpc                   ## Mac OS
```

Then in R, source the script (*Be aware of the risks running a script from online sources*)
and press Enter to select the default options:

```r
source("https://raw.githubusercontent.com/symengine/symengine.R/master/tools/install-symengine.R")
```

If it was successful, you can install the R package with

```{r, eval=FALSE}
devtools::install_github(
  "symengine/symengine.R",
  build_opts = c("--no-resave-data", "--no-manual") # Build Vignettes
)
```

On Windows, the dependencies will be downloaded at build time, and you can install
directly with `devtools`.

Please report any problem installing the package on your system.

```{r}
library(symengine)
```

## Usage

### Manipulating Symbolic Expressions

```{r}
use_vars(x, y, z)
expr <- (x + y + z) ^ 2L - 42L
expand(expr)
```

Substitue `z` as `a` and `y` as `x^2`.

```{r}
a <- S("a")
expr <- subs(expr, z, a)
expr <- subs(expr, y, x^2L)
expr
```

Second derivative of `expr` with regards to `x`:

```{r}
d1_expr <- D(expr, "x")
d2_expr <- D(d1_expr, "x")
expand(d2_expr)
```

Solve the equation of `d2_expr == 0` with regards to `x`.

```{r}
solutions <- solve(d2_expr, "x")
solutions
```

### Numerically Evaluate Symbolic Expressions

For the two solutions above, we can convert them into a function that gives numeric
output with regards to given input.

```{r}
func <- as.function(solutions)
ans <- func(a = -100:-95)
colnames(ans) <- c("Solution1", "Solution2")
ans
```


### Numbers

The next prime number greater than 2^400.

```{r}
n <- nextprime(S(~ 2 ^ 400))
n
```

The greatest common divisor between the prime number and 42.

```{r}
GCD(n, 42)
```

The binomial coefficient `(2^30 Â¦ 5)`.

```{r}
choose(S(~ 2^30), 5L)
```

Pi "computed" to 400-bit precision number.

```{r}
if (symengine_have_component("mpfr"))
    evalf(Constant("pi"), bits = 400)
```

### Object Equality

```{r}
x + y == S("x + y")
x + y != S("x + y")
```

```{r}
sin(x)/cos(x)
tan(x) == sin(x)/cos(x) # Different internal representation
```

## Acknowledgement

This project was a Google Summer of Code project under the organization
of The R Project for Statistical Computing in 2018.
The student was Xin Chen, mentored by Jialin Ma and Isuru Fernando.
